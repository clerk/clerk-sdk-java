/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.clerk.backend_api;

import static com.clerk.backend_api.operations.Operations.RequestOperation;

import com.clerk.backend_api.models.operations.CreateMachineRequestBody;
import com.clerk.backend_api.models.operations.CreateMachineRequestBuilder;
import com.clerk.backend_api.models.operations.CreateMachineResponse;
import com.clerk.backend_api.models.operations.CreateMachineScopeRequest;
import com.clerk.backend_api.models.operations.CreateMachineScopeRequestBody;
import com.clerk.backend_api.models.operations.CreateMachineScopeRequestBuilder;
import com.clerk.backend_api.models.operations.CreateMachineScopeResponse;
import com.clerk.backend_api.models.operations.DeleteMachineRequest;
import com.clerk.backend_api.models.operations.DeleteMachineRequestBuilder;
import com.clerk.backend_api.models.operations.DeleteMachineResponse;
import com.clerk.backend_api.models.operations.DeleteMachineScopeRequest;
import com.clerk.backend_api.models.operations.DeleteMachineScopeRequestBuilder;
import com.clerk.backend_api.models.operations.DeleteMachineScopeResponse;
import com.clerk.backend_api.models.operations.GetMachineRequest;
import com.clerk.backend_api.models.operations.GetMachineRequestBuilder;
import com.clerk.backend_api.models.operations.GetMachineResponse;
import com.clerk.backend_api.models.operations.GetMachineSecretKeyRequest;
import com.clerk.backend_api.models.operations.GetMachineSecretKeyRequestBuilder;
import com.clerk.backend_api.models.operations.GetMachineSecretKeyResponse;
import com.clerk.backend_api.models.operations.ListMachinesRequest;
import com.clerk.backend_api.models.operations.ListMachinesRequestBuilder;
import com.clerk.backend_api.models.operations.ListMachinesResponse;
import com.clerk.backend_api.models.operations.RotateMachineSecretKeyRequest;
import com.clerk.backend_api.models.operations.RotateMachineSecretKeyRequestBody;
import com.clerk.backend_api.models.operations.RotateMachineSecretKeyRequestBuilder;
import com.clerk.backend_api.models.operations.RotateMachineSecretKeyResponse;
import com.clerk.backend_api.models.operations.UpdateMachineRequest;
import com.clerk.backend_api.models.operations.UpdateMachineRequestBody;
import com.clerk.backend_api.models.operations.UpdateMachineRequestBuilder;
import com.clerk.backend_api.models.operations.UpdateMachineResponse;
import com.clerk.backend_api.operations.CreateMachine;
import com.clerk.backend_api.operations.CreateMachineScope;
import com.clerk.backend_api.operations.DeleteMachine;
import com.clerk.backend_api.operations.DeleteMachineScope;
import com.clerk.backend_api.operations.GetMachine;
import com.clerk.backend_api.operations.GetMachineSecretKey;
import com.clerk.backend_api.operations.ListMachines;
import com.clerk.backend_api.operations.RotateMachineSecretKey;
import com.clerk.backend_api.operations.UpdateMachine;
import com.clerk.backend_api.utils.Headers;
import com.clerk.backend_api.utils.Options;
import java.lang.Long;
import java.lang.String;
import java.util.Optional;


public class Machines {
    private static final Headers _headers = Headers.EMPTY;
    private final SDKConfiguration sdkConfiguration;

    Machines(SDKConfiguration sdkConfiguration) {
        this.sdkConfiguration = sdkConfiguration;
    }

    /**
     * Get a list of machines for an instance
     * 
     * <p>This request returns the list of machines for an instance. The machines are
     * ordered by descending creation date (i.e. most recent machines will be
     * returned first)
     * 
     * @return The call builder
     */
    public ListMachinesRequestBuilder list() {
        return new ListMachinesRequestBuilder(sdkConfiguration);
    }

    /**
     * Get a list of machines for an instance
     * 
     * <p>This request returns the list of machines for an instance. The machines are
     * ordered by descending creation date (i.e. most recent machines will be
     * returned first)
     * 
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public ListMachinesResponse listDirect() {
        return list(Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty());
    }

    /**
     * Get a list of machines for an instance
     * 
     * <p>This request returns the list of machines for an instance. The machines are
     * ordered by descending creation date (i.e. most recent machines will be
     * returned first)
     * 
     * @param limit Applies a limit to the number of results returned.
     *         Can be used for paginating the results together with `offset`.
     * @param offset Skip the first `offset` results when paginating.
     *         Needs to be an integer greater or equal to zero.
     *         To be used in conjunction with `limit`.
     * @param query Returns machines with ID or name that match the given query. Uses exact match for machine ID and partial match for name.
     * @param orderBy Allows to return machines in a particular order.
     *         You can order the returned machines by their `name` or `created_at`.
     *         To specify the direction, use the `+` or `-` symbols prepended to the property to order by.
     *         For example, to return machines in descending order by `created_at`, use `-created_at`.
     *         If you don't use `+` or `-`, then `+` is implied.
     *         Defaults to `-created_at`.
     * @param options additional options
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public ListMachinesResponse list(
            Optional<Long> limit, Optional<Long> offset,
            Optional<String> query, Optional<String> orderBy,
            Optional<Options> options) {
        ListMachinesRequest request =
            ListMachinesRequest
                .builder()
                .limit(limit)
                .offset(offset)
                .query(query)
                .orderBy(orderBy)
                .build();
        RequestOperation<ListMachinesRequest, ListMachinesResponse> operation
              = new ListMachines.Sync(sdkConfiguration, options, _headers);
        return operation.handleResponse(operation.doRequest(request));
    }

    /**
     * Create a machine
     * 
     * <p>Creates a new machine.
     * 
     * @return The call builder
     */
    public CreateMachineRequestBuilder create() {
        return new CreateMachineRequestBuilder(sdkConfiguration);
    }

    /**
     * Create a machine
     * 
     * <p>Creates a new machine.
     * 
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public CreateMachineResponse createDirect() {
        return create(Optional.empty(), Optional.empty());
    }

    /**
     * Create a machine
     * 
     * <p>Creates a new machine.
     * 
     * @param request The request object containing all the parameters for the API call.
     * @param options additional options
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public CreateMachineResponse create(Optional<? extends CreateMachineRequestBody> request, Optional<Options> options) {
        RequestOperation<Optional<? extends CreateMachineRequestBody>, CreateMachineResponse> operation
              = new CreateMachine.Sync(sdkConfiguration, options, _headers);
        return operation.handleResponse(operation.doRequest(request));
    }

    /**
     * Retrieve a machine
     * 
     * <p>Returns the details of a machine.
     * 
     * @return The call builder
     */
    public GetMachineRequestBuilder get() {
        return new GetMachineRequestBuilder(sdkConfiguration);
    }

    /**
     * Retrieve a machine
     * 
     * <p>Returns the details of a machine.
     * 
     * @param machineId The ID of the machine to retrieve
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public GetMachineResponse get(String machineId) {
        return get(machineId, Optional.empty());
    }

    /**
     * Retrieve a machine
     * 
     * <p>Returns the details of a machine.
     * 
     * @param machineId The ID of the machine to retrieve
     * @param options additional options
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public GetMachineResponse get(String machineId, Optional<Options> options) {
        GetMachineRequest request =
            GetMachineRequest
                .builder()
                .machineId(machineId)
                .build();
        RequestOperation<GetMachineRequest, GetMachineResponse> operation
              = new GetMachine.Sync(sdkConfiguration, options, _headers);
        return operation.handleResponse(operation.doRequest(request));
    }

    /**
     * Update a machine
     * 
     * <p>Updates an existing machine.
     * Only the provided fields will be updated.
     * 
     * @return The call builder
     */
    public UpdateMachineRequestBuilder update() {
        return new UpdateMachineRequestBuilder(sdkConfiguration);
    }

    /**
     * Update a machine
     * 
     * <p>Updates an existing machine.
     * Only the provided fields will be updated.
     * 
     * @param machineId The ID of the machine to update
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public UpdateMachineResponse update(String machineId) {
        return update(machineId, Optional.empty(), Optional.empty());
    }

    /**
     * Update a machine
     * 
     * <p>Updates an existing machine.
     * Only the provided fields will be updated.
     * 
     * @param machineId The ID of the machine to update
     * @param requestBody 
     * @param options additional options
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public UpdateMachineResponse update(
            String machineId, Optional<? extends UpdateMachineRequestBody> requestBody,
            Optional<Options> options) {
        UpdateMachineRequest request =
            UpdateMachineRequest
                .builder()
                .machineId(machineId)
                .requestBody(requestBody)
                .build();
        RequestOperation<UpdateMachineRequest, UpdateMachineResponse> operation
              = new UpdateMachine.Sync(sdkConfiguration, options, _headers);
        return operation.handleResponse(operation.doRequest(request));
    }

    /**
     * Delete a machine
     * 
     * <p>Deletes a machine.
     * 
     * @return The call builder
     */
    public DeleteMachineRequestBuilder delete() {
        return new DeleteMachineRequestBuilder(sdkConfiguration);
    }

    /**
     * Delete a machine
     * 
     * <p>Deletes a machine.
     * 
     * @param machineId The ID of the machine to delete
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public DeleteMachineResponse delete(String machineId) {
        return delete(machineId, Optional.empty());
    }

    /**
     * Delete a machine
     * 
     * <p>Deletes a machine.
     * 
     * @param machineId The ID of the machine to delete
     * @param options additional options
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public DeleteMachineResponse delete(String machineId, Optional<Options> options) {
        DeleteMachineRequest request =
            DeleteMachineRequest
                .builder()
                .machineId(machineId)
                .build();
        RequestOperation<DeleteMachineRequest, DeleteMachineResponse> operation
              = new DeleteMachine.Sync(sdkConfiguration, options, _headers);
        return operation.handleResponse(operation.doRequest(request));
    }

    /**
     * Retrieve a machine secret key
     * 
     * <p>Returns the secret key for a machine.
     * 
     * @return The call builder
     */
    public GetMachineSecretKeyRequestBuilder getSecretKey() {
        return new GetMachineSecretKeyRequestBuilder(sdkConfiguration);
    }

    /**
     * Retrieve a machine secret key
     * 
     * <p>Returns the secret key for a machine.
     * 
     * @param machineId The ID of the machine to retrieve the secret key for
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public GetMachineSecretKeyResponse getSecretKey(String machineId) {
        return getSecretKey(machineId, Optional.empty());
    }

    /**
     * Retrieve a machine secret key
     * 
     * <p>Returns the secret key for a machine.
     * 
     * @param machineId The ID of the machine to retrieve the secret key for
     * @param options additional options
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public GetMachineSecretKeyResponse getSecretKey(String machineId, Optional<Options> options) {
        GetMachineSecretKeyRequest request =
            GetMachineSecretKeyRequest
                .builder()
                .machineId(machineId)
                .build();
        RequestOperation<GetMachineSecretKeyRequest, GetMachineSecretKeyResponse> operation
              = new GetMachineSecretKey.Sync(sdkConfiguration, options, _headers);
        return operation.handleResponse(operation.doRequest(request));
    }

    /**
     * Rotate a machine's secret key
     * 
     * <p>Rotates the machine's secret key.
     * When the secret key is rotated, make sure to update it in your machine/application.
     * The previous secret key will remain valid for the duration specified by the previous_token_ttl
     * parameter.
     * 
     * @return The call builder
     */
    public RotateMachineSecretKeyRequestBuilder rotateSecretKey() {
        return new RotateMachineSecretKeyRequestBuilder(sdkConfiguration);
    }

    /**
     * Rotate a machine's secret key
     * 
     * <p>Rotates the machine's secret key.
     * When the secret key is rotated, make sure to update it in your machine/application.
     * The previous secret key will remain valid for the duration specified by the previous_token_ttl
     * parameter.
     * 
     * @param machineId The ID of the machine to rotate the secret key for
     * @param requestBody 
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public RotateMachineSecretKeyResponse rotateSecretKey(String machineId, RotateMachineSecretKeyRequestBody requestBody) {
        return rotateSecretKey(machineId, requestBody, Optional.empty());
    }

    /**
     * Rotate a machine's secret key
     * 
     * <p>Rotates the machine's secret key.
     * When the secret key is rotated, make sure to update it in your machine/application.
     * The previous secret key will remain valid for the duration specified by the previous_token_ttl
     * parameter.
     * 
     * @param machineId The ID of the machine to rotate the secret key for
     * @param requestBody 
     * @param options additional options
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public RotateMachineSecretKeyResponse rotateSecretKey(
            String machineId, RotateMachineSecretKeyRequestBody requestBody,
            Optional<Options> options) {
        RotateMachineSecretKeyRequest request =
            RotateMachineSecretKeyRequest
                .builder()
                .machineId(machineId)
                .requestBody(requestBody)
                .build();
        RequestOperation<RotateMachineSecretKeyRequest, RotateMachineSecretKeyResponse> operation
              = new RotateMachineSecretKey.Sync(sdkConfiguration, options, _headers);
        return operation.handleResponse(operation.doRequest(request));
    }

    /**
     * Create a machine scope
     * 
     * <p>Creates a new machine scope, allowing the specified machine to access another machine.
     * Maximum of 25 scopes per machine.
     * 
     * @return The call builder
     */
    public CreateMachineScopeRequestBuilder createScope() {
        return new CreateMachineScopeRequestBuilder(sdkConfiguration);
    }

    /**
     * Create a machine scope
     * 
     * <p>Creates a new machine scope, allowing the specified machine to access another machine.
     * Maximum of 25 scopes per machine.
     * 
     * @param machineId The ID of the machine that will have access to another machine
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public CreateMachineScopeResponse createScope(String machineId) {
        return createScope(machineId, Optional.empty(), Optional.empty());
    }

    /**
     * Create a machine scope
     * 
     * <p>Creates a new machine scope, allowing the specified machine to access another machine.
     * Maximum of 25 scopes per machine.
     * 
     * @param machineId The ID of the machine that will have access to another machine
     * @param requestBody 
     * @param options additional options
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public CreateMachineScopeResponse createScope(
            String machineId, Optional<? extends CreateMachineScopeRequestBody> requestBody,
            Optional<Options> options) {
        CreateMachineScopeRequest request =
            CreateMachineScopeRequest
                .builder()
                .machineId(machineId)
                .requestBody(requestBody)
                .build();
        RequestOperation<CreateMachineScopeRequest, CreateMachineScopeResponse> operation
              = new CreateMachineScope.Sync(sdkConfiguration, options, _headers);
        return operation.handleResponse(operation.doRequest(request));
    }

    /**
     * Delete a machine scope
     * 
     * <p>Deletes a machine scope, removing access from one machine to another.
     * 
     * @return The call builder
     */
    public DeleteMachineScopeRequestBuilder deleteScope() {
        return new DeleteMachineScopeRequestBuilder(sdkConfiguration);
    }

    /**
     * Delete a machine scope
     * 
     * <p>Deletes a machine scope, removing access from one machine to another.
     * 
     * @param machineId The ID of the machine that has access to another machine
     * @param otherMachineId The ID of the machine that is being accessed
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public DeleteMachineScopeResponse deleteScope(String machineId, String otherMachineId) {
        return deleteScope(machineId, otherMachineId, Optional.empty());
    }

    /**
     * Delete a machine scope
     * 
     * <p>Deletes a machine scope, removing access from one machine to another.
     * 
     * @param machineId The ID of the machine that has access to another machine
     * @param otherMachineId The ID of the machine that is being accessed
     * @param options additional options
     * @return The response from the API call
     * @throws RuntimeException subclass if the API call fails
     */
    public DeleteMachineScopeResponse deleteScope(
            String machineId, String otherMachineId,
            Optional<Options> options) {
        DeleteMachineScopeRequest request =
            DeleteMachineScopeRequest
                .builder()
                .machineId(machineId)
                .otherMachineId(otherMachineId)
                .build();
        RequestOperation<DeleteMachineScopeRequest, DeleteMachineScopeResponse> operation
              = new DeleteMachineScope.Sync(sdkConfiguration, options, _headers);
        return operation.handleResponse(operation.doRequest(request));
    }

}
